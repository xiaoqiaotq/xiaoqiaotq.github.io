<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Antlr4初学 | xiaoqiaotq</title><meta name=keywords content="Antlr4,JAVA,DSL"><meta name=description content="背景 项目需要实现前端任意字段匹配查询，故需要配合表达式来生产sql，其实就是定义一种DSL，让前后端相互了解这个语意，调研后决定使用Antlr，相关介绍就不过分多说，直接看效果。语法参考Odata filter ，后期不满足可以直接修改g4文件
Odata filter示例 Country_Region_Code eq 'ES' or Country_Region_Code eq 'US' Country_Region_Code eq 'ES' and Payment_Terms_Code eq '14 DAYS' Entry_No ge 610 Entry_No lt 610 VAT_Bus_Posting_Group ne 'EXPORT' Odata.g4 grammar OData; /* * Parser Rules */ program: expression; expression: LP expression RP # Parenthesis | K_STARTSWITH LP column=column_name ',' value=TEXT RP # StartsWith | K_ENDSWITH LP column=column_name ',' value=TEXT RP # EndsWith | K_CONTAINS LP column=column_name ',' value=TEXT RP # Contains | column=column_name K_IN LP value=decimal_array RP # InDecimal | column=column_name K_IN LP value=string_array RP # InText | column=column_name compare=( Equal | NotEqual | GreaterThan | GreaterThanOrEqual | LessThan | LessThanOrEqual) value=decimal # CompareDecimal | column=column_name compare=( Equal | NotEqual | GreaterThan | GreaterThanOrEqual | LessThan | LessThanOrEqual) value=TEXT # CompareText | expression logic = (K_AND | K_OR) expression	# Logic ; column_name : COLUMN_NAME | '[' column_name ']' ; string_array : TEXT (',' TEXT)* ; decimal_array : NUMBER (',' NUMBER)* ; text: TEXT; decimal : NUMBER ; /* * Lexer Rules */ K_IN: I N; K_AND: A N D; K_OR: O R; K_STARTSWITH: S T A R T S W I T H; K_ENDSWITH: E N D S W I T H; K_CONTAINS: C O N T A I N S; LP : '('; RP : ')'; Equal: E Q; NotEqual: N E; GreaterThan: G T; GreaterThanOrEqual: G E; LessThan: L T; LessThanOrEqual: L E; COLUMN_NAME : VALID_ID_START VALID_ID_CHAR* ; TEXT :'&#34;' ."><meta name=author content><link rel=canonical href=https://xiaoqiaotq.github.io/posts/misc/antlr4%E5%88%9D%E5%AD%A6/><link crossorigin=anonymous href=/assets/css/stylesheet.min.c88963fe2d79462000fd0fb1b3737783c32855d340583e4523343f8735c787f0.css integrity="sha256-yIlj/i15RiAA/Q+xs3N3g8MoVdNAWD5FIzQ/hzXHh/A=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xiaoqiaotq.github.io/64%2A64.ico><link rel=icon type=image/png sizes=16x16 href=https://xiaoqiaotq.github.io/16%2A16.ico><link rel=icon type=image/png sizes=32x32 href=https://xiaoqiaotq.github.io/32%2A32.ico><link rel=apple-touch-icon href=https://xiaoqiaotq.github.io/64%2A64.ico><link rel=mask-icon href=https://xiaoqiaotq.github.io/64%2A64.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.110.0"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Antlr4初学"><meta property="og:description" content="背景 项目需要实现前端任意字段匹配查询，故需要配合表达式来生产sql，其实就是定义一种DSL，让前后端相互了解这个语意，调研后决定使用Antlr，相关介绍就不过分多说，直接看效果。语法参考Odata filter ，后期不满足可以直接修改g4文件
Odata filter示例 Country_Region_Code eq 'ES' or Country_Region_Code eq 'US' Country_Region_Code eq 'ES' and Payment_Terms_Code eq '14 DAYS' Entry_No ge 610 Entry_No lt 610 VAT_Bus_Posting_Group ne 'EXPORT' Odata.g4 grammar OData; /* * Parser Rules */ program: expression; expression: LP expression RP # Parenthesis | K_STARTSWITH LP column=column_name ',' value=TEXT RP # StartsWith | K_ENDSWITH LP column=column_name ',' value=TEXT RP # EndsWith | K_CONTAINS LP column=column_name ',' value=TEXT RP # Contains | column=column_name K_IN LP value=decimal_array RP # InDecimal | column=column_name K_IN LP value=string_array RP # InText | column=column_name compare=( Equal | NotEqual | GreaterThan | GreaterThanOrEqual | LessThan | LessThanOrEqual) value=decimal # CompareDecimal | column=column_name compare=( Equal | NotEqual | GreaterThan | GreaterThanOrEqual | LessThan | LessThanOrEqual) value=TEXT # CompareText | expression logic = (K_AND | K_OR) expression	# Logic ; column_name : COLUMN_NAME | '[' column_name ']' ; string_array : TEXT (',' TEXT)* ; decimal_array : NUMBER (',' NUMBER)* ; text: TEXT; decimal : NUMBER ; /* * Lexer Rules */ K_IN: I N; K_AND: A N D; K_OR: O R; K_STARTSWITH: S T A R T S W I T H; K_ENDSWITH: E N D S W I T H; K_CONTAINS: C O N T A I N S; LP : '('; RP : ')'; Equal: E Q; NotEqual: N E; GreaterThan: G T; GreaterThanOrEqual: G E; LessThan: L T; LessThanOrEqual: L E; COLUMN_NAME : VALID_ID_START VALID_ID_CHAR* ; TEXT :'&#34;' ."><meta property="og:type" content="article"><meta property="og:url" content="https://xiaoqiaotq.github.io/posts/misc/antlr4%E5%88%9D%E5%AD%A6/"><meta property="og:image" content="https://cn.bing.com/th?id=OHR.QuebecFrontenac_ZH-CN9519096458_1920x1080.jpg&rf=LaDigue_1920x1080.jpg&pid=hp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-08T22:09:26+08:00"><meta property="article:modified_time" content="2023-01-08T22:09:26+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://cn.bing.com/th?id=OHR.QuebecFrontenac_ZH-CN9519096458_1920x1080.jpg&rf=LaDigue_1920x1080.jpg&pid=hp"><meta name=twitter:title content="Antlr4初学"><meta name=twitter:description content="背景 项目需要实现前端任意字段匹配查询，故需要配合表达式来生产sql，其实就是定义一种DSL，让前后端相互了解这个语意，调研后决定使用Antlr，相关介绍就不过分多说，直接看效果。语法参考Odata filter ，后期不满足可以直接修改g4文件
Odata filter示例 Country_Region_Code eq 'ES' or Country_Region_Code eq 'US' Country_Region_Code eq 'ES' and Payment_Terms_Code eq '14 DAYS' Entry_No ge 610 Entry_No lt 610 VAT_Bus_Posting_Group ne 'EXPORT' Odata.g4 grammar OData; /* * Parser Rules */ program: expression; expression: LP expression RP # Parenthesis | K_STARTSWITH LP column=column_name ',' value=TEXT RP # StartsWith | K_ENDSWITH LP column=column_name ',' value=TEXT RP # EndsWith | K_CONTAINS LP column=column_name ',' value=TEXT RP # Contains | column=column_name K_IN LP value=decimal_array RP # InDecimal | column=column_name K_IN LP value=string_array RP # InText | column=column_name compare=( Equal | NotEqual | GreaterThan | GreaterThanOrEqual | LessThan | LessThanOrEqual) value=decimal # CompareDecimal | column=column_name compare=( Equal | NotEqual | GreaterThan | GreaterThanOrEqual | LessThan | LessThanOrEqual) value=TEXT # CompareText | expression logic = (K_AND | K_OR) expression	# Logic ; column_name : COLUMN_NAME | '[' column_name ']' ; string_array : TEXT (',' TEXT)* ; decimal_array : NUMBER (',' NUMBER)* ; text: TEXT; decimal : NUMBER ; /* * Lexer Rules */ K_IN: I N; K_AND: A N D; K_OR: O R; K_STARTSWITH: S T A R T S W I T H; K_ENDSWITH: E N D S W I T H; K_CONTAINS: C O N T A I N S; LP : '('; RP : ')'; Equal: E Q; NotEqual: N E; GreaterThan: G T; GreaterThanOrEqual: G E; LessThan: L T; LessThanOrEqual: L E; COLUMN_NAME : VALID_ID_START VALID_ID_CHAR* ; TEXT :'&#34;' ."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://xiaoqiaotq.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Antlr4初学","item":"https://xiaoqiaotq.github.io/posts/misc/antlr4%E5%88%9D%E5%AD%A6/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Antlr4初学","name":"Antlr4初学","description":"背景 项目需要实现前端任意字段匹配查询，故需要配合表达式来生产sql，其实就是定义一种DSL，让前后端相互了解这个语意，调研后决定使用Antlr，相关介绍就不过分多说，直接看效果。语法参考Odata filter ，后期不满足可以直接修改g4文件\nOdata filter示例 Country_Region_Code eq \u0026#39;ES\u0026#39; or Country_Region_Code eq \u0026#39;US\u0026#39; Country_Region_Code eq \u0026#39;ES\u0026#39; and Payment_Terms_Code eq \u0026#39;14 DAYS\u0026#39; Entry_No ge 610 Entry_No lt 610 VAT_Bus_Posting_Group ne \u0026#39;EXPORT\u0026#39; Odata.g4 grammar OData; /* * Parser Rules */ program: expression; expression: LP expression RP # Parenthesis | K_STARTSWITH LP column=column_name \u0026#39;,\u0026#39; value=TEXT RP # StartsWith | K_ENDSWITH LP column=column_name \u0026#39;,\u0026#39; value=TEXT RP # EndsWith | K_CONTAINS LP column=column_name \u0026#39;,\u0026#39; value=TEXT RP # Contains | column=column_name K_IN LP value=decimal_array RP # InDecimal | column=column_name K_IN LP value=string_array RP # InText | column=column_name compare=( Equal | NotEqual | GreaterThan | GreaterThanOrEqual | LessThan | LessThanOrEqual) value=decimal # CompareDecimal | column=column_name compare=( Equal | NotEqual | GreaterThan | GreaterThanOrEqual | LessThan | LessThanOrEqual) value=TEXT # CompareText | expression logic = (K_AND | K_OR) expression\t# Logic ; column_name : COLUMN_NAME | \u0026#39;[\u0026#39; column_name \u0026#39;]\u0026#39; ; string_array : TEXT (\u0026#39;,\u0026#39; TEXT)* ; decimal_array : NUMBER (\u0026#39;,\u0026#39; NUMBER)* ; text: TEXT; decimal : NUMBER ; /* * Lexer Rules */ K_IN: I N; K_AND: A N D; K_OR: O R; K_STARTSWITH: S T A R T S W I T H; K_ENDSWITH: E N D S W I T H; K_CONTAINS: C O N T A I N S; LP : \u0026#39;(\u0026#39;; RP : \u0026#39;)\u0026#39;; Equal: E Q; NotEqual: N E; GreaterThan: G T; GreaterThanOrEqual: G E; LessThan: L T; LessThanOrEqual: L E; COLUMN_NAME : VALID_ID_START VALID_ID_CHAR* ; TEXT :\u0026#39;\u0026#34;\u0026#39; .","keywords":["Antlr4","JAVA","DSL"],"articleBody":"背景 项目需要实现前端任意字段匹配查询，故需要配合表达式来生产sql，其实就是定义一种DSL，让前后端相互了解这个语意，调研后决定使用Antlr，相关介绍就不过分多说，直接看效果。语法参考Odata filter ，后期不满足可以直接修改g4文件\nOdata filter示例 Country_Region_Code eq 'ES' or Country_Region_Code eq 'US' Country_Region_Code eq 'ES' and Payment_Terms_Code eq '14 DAYS' Entry_No ge 610 Entry_No lt 610 VAT_Bus_Posting_Group ne 'EXPORT' Odata.g4 grammar OData; /* * Parser Rules */ program: expression; expression: LP expression RP # Parenthesis | K_STARTSWITH LP column=column_name ',' value=TEXT RP # StartsWith | K_ENDSWITH LP column=column_name ',' value=TEXT RP # EndsWith | K_CONTAINS LP column=column_name ',' value=TEXT RP # Contains | column=column_name K_IN LP value=decimal_array RP # InDecimal | column=column_name K_IN LP value=string_array RP # InText | column=column_name compare=( Equal | NotEqual | GreaterThan | GreaterThanOrEqual | LessThan | LessThanOrEqual) value=decimal # CompareDecimal | column=column_name compare=( Equal | NotEqual | GreaterThan | GreaterThanOrEqual | LessThan | LessThanOrEqual) value=TEXT # CompareText | expression logic = (K_AND | K_OR) expression\t# Logic ; column_name : COLUMN_NAME | '[' column_name ']' ; string_array : TEXT (',' TEXT)* ; decimal_array : NUMBER (',' NUMBER)* ; text: TEXT; decimal : NUMBER ; /* * Lexer Rules */ K_IN: I N; K_AND: A N D; K_OR: O R; K_STARTSWITH: S T A R T S W I T H; K_ENDSWITH: E N D S W I T H; K_CONTAINS: C O N T A I N S; LP : '('; RP : ')'; Equal: E Q; NotEqual: N E; GreaterThan: G T; GreaterThanOrEqual: G E; LessThan: L T; LessThanOrEqual: L E; COLUMN_NAME : VALID_ID_START VALID_ID_CHAR* ; TEXT :'\"' .*? '\"' |'\\'' .*? '\\'' ; NUMBER : (SIGN)? UNSIGNED_INTEGER+ | (SIGN)? UNSIGNED_INTEGER+ ('.' UNSIGNED_INTEGER+)? ; fragment UNSIGNED_INTEGER : ('0' .. '9') ; fragment SIGN : ('+' | '-') ; fragment VALID_ID_START : LOWERCASE | UPERCASE | '_' ; fragment VALID_ID_CHAR : VALID_ID_START | (LOWERCASE | UPERCASE | DIGIT ) ; fragment LOWERCASE: [a-z]; fragment UPERCASE: [A-Z]; fragment DIGIT: [0-9]; fragment DIGITS: DIGIT+; fragment A: [aA]; fragment B: [bB]; fragment C: [cC]; fragment D: [dD]; fragment E: [eE]; fragment F: [fF]; fragment G: [gG]; fragment H: [hH]; fragment I: [iI]; fragment J: [jJ]; fragment K: [kK]; fragment L: [lL]; fragment M: [mM]; fragment N: [nN]; fragment O: [oO]; fragment P: [pP]; fragment Q: [qQ]; fragment R: [rR]; fragment S: [sS]; fragment T: [tT]; fragment U: [uU]; fragment V: [vV]; fragment W: [wW]; fragment X: [xX]; fragment Y: [yY]; fragment Z: [zZ]; SPACES: [ \\u000B\\t\\r\\n] -\u003e channel(HIDDEN); 前端 UI npm包 npm i antlr4@4.11.0\nVisitor（DSL to js） // This class defines a complete generic visitor for a parse tree produced by ODataParser. import ODataParser from \"@/project/antlr/ODataParser\"; import ODataVisitor from \"@/project/antlr/ODataVisitor\"; export default class ODataSqlVisitor extends ODataVisitor { filterPair={ logic:'AND', pairs:[] } getFilterPair(){ return this.filterPair } // Visit a parse tree produced by ODataParser#CompareText. visitCompareText(ctx) { if (ctx.exception!=null) { throw ctx.exception; } const column = this.visit(ctx.column); const decimal= ctx.value.text.replace(/^\"(.*)\"$/,\"$1\") const operator = this.getSQLOperator(ctx.compare.type); const pair= {column ,value: decimal,operator}; this.filterPair.pairs.push(pair) return pair; } // Visit a parse tree produced by ODataParser#CompareDecimal. visitCompareDecimal(ctx) { if (ctx.exception!=null) { throw ctx.exception; } const column = this.visit(ctx.column); const decimal = this.visit(ctx.value); const operator = this.getSQLOperator(ctx.compare.type); // return column + \" \" + operator + \" \" + decimal; const pair= {column ,value: decimal,operator}; this.filterPair.pairs.push(pair) return pair; } // Visit a parse tree produced by ODataParser#Logic. visitLogic(ctx){ if(ctx.exception!=null) { throw ctx.exception; } const left = this.visit(ctx.expression(0)); const right = this.visit(ctx.expression(1)); if (right == null){ return null; } if (ctx.logic.type== ODataParser.K_AND) { this.filterPair.logic = \"AND\"; // return left + \" and \" + right; return null; }else { this.filterPair.logic = \"OR\"; // return left + \" or \" + right; return null; } } // Visit a parse tree produced by ODataParser#column_name. visitColumn_name(ctx) { return ctx.getText(); } // Visit a parse tree produced by ODataParser#decimal. visitDecimal(ctx) { return ctx.getText(); } // visitText(ctx) { // const aa= ctx.getText().replace(/^\"(.*)\"$/,\"$1\") // console.log(aa,ctx.getText()) // debugger // return aa // } getSQLOperator(compare) { let operator = null; switch (compare) { case ODataParser.Equal: operator = \"=\"; break; case ODataParser.NotEqual: operator = \"\u003c\u003e\"; break; case ODataParser.GreaterThan: operator = \"\u003e\"; break; case ODataParser.GreaterThanOrEqual: operator = \"\u003e=\"; break; case ODataParser.LessThan: operator = \"\u003c\"; break; case ODataParser.LessThanOrEqual: operator = \"\u003c=\"; break; } return operator; } } 后端 maven坐标 org.antlr antlr4-runtime 4.11.1 Visitor（DSL to sql） 和工具类 package com.sankyu.wms.antlr; import com.google.common.base.CaseFormat; public class ODataSqlVisitor extends ODataBaseVisitor { @Override public Object visitLogic(ODataParser.LogicContext ctx) { if (ctx.exception!=null) { throw ctx.exception; } String left = (String) visit(ctx.expression(0)); String right = (String) visit(ctx.expression(1)); if (right == null){ return null; } if (ctx.logic.getType()==ODataParser.K_AND) { return left + \" and \" + right; }else { return left + \" or \" + right; } } @Override public Object visitColumn_name(ODataParser.Column_nameContext ctx) { return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, ctx.getText()); } @Override public Object visitDecimal(ODataParser.DecimalContext ctx) { return ctx.getText(); } // @Override // public Object visitText(ODataParser.TextContext ctx) { // return ctx.getText(); // } @Override public Object visitCompareDecimal(ODataParser.CompareDecimalContext ctx) { if (ctx.exception!=null) { throw ctx.exception; } String column = (String)visit(ctx.column); String decimal = (String)visit(ctx.value); String operator = getSQLOperator(ctx.compare.getType()); return column + \" \" + operator + \" \" + decimal; } @Override public Object visitCompareText(ODataParser.CompareTextContext ctx) { if (ctx.exception!=null) { throw ctx.exception; } String column = (String)visit(ctx.column); String decimal = ctx.value.getText(); String operator = getSQLOperator(ctx.compare.getType()); return column + \" \" + operator + \" \" + decimal; } private String getSQLOperator(Integer compare) { String operator = null; switch (compare) { case ODataParser.Equal: operator = \"=\"; break; case ODataParser.NotEqual: operator = \"\u003c\u003e\"; break; case ODataParser.GreaterThan: operator = \"\u003e\"; break; case ODataParser.GreaterThanOrEqual: operator = \"\u003e=\"; break; case ODataParser.LessThan: operator = \"\u003c\"; break; case ODataParser.LessThanOrEqual: operator = \"\u003c=\"; break; } return operator; } } 参考 https://olingo.apache.org/doc/odata2/tutorials/Olingo_Tutorial_AdvancedRead_FilterVisitor.html https://blog.51cto.com/u_15067225/2603738 https://learn.microsoft.com/en-us/dynamics-nav/using-filter-expressions-in-odata-uris https://github.com/huazailmh/ODataFilterParser/blob/master/Parser/ODataFilterVisitor.cs ","wordCount":"911","inLanguage":"en","image":"https://cn.bing.com/th?id=OHR.QuebecFrontenac_ZH-CN9519096458_1920x1080.jpg\u0026rf=LaDigue_1920x1080.jpg\u0026pid=hp","datePublished":"2023-01-08T22:09:26+08:00","dateModified":"2023-01-08T22:09:26+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://xiaoqiaotq.github.io/posts/misc/antlr4%E5%88%9D%E5%AD%A6/"},"publisher":{"@type":"Organization","name":"xiaoqiaotq","logo":{"@type":"ImageObject","url":"https://xiaoqiaotq.github.io/64%2A64.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xiaoqiaotq.github.io accesskey=h title="xiaoqiaotq (Alt + H)">xiaoqiaotq</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://xiaoqiaotq.github.io/archives title=总览><span>总览</span></a></li><li><a href=https://xiaoqiaotq.github.io/search/ title=搜索><span>搜索</span></a></li><li><a href=https://xiaoqiaotq.github.io/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Antlr4初学</h1><div class=post-meta><span title='2023-01-08 22:09:26 +0800 +0800'>January 8, 2023</span></div></header><div class=post-content><h4 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h4><p>项目需要实现前端任意字段匹配查询，故需要配合表达式来生产sql，其实就是定义一种DSL，让前后端相互了解这个语意，调研后决定使用Antlr，相关介绍就不过分多说，直接看效果。语法参考Odata filter ，后期不满足可以直接修改g4文件</p><h4 id=odata-filter示例>Odata filter示例<a hidden class=anchor aria-hidden=true href=#odata-filter示例>#</a></h4><pre tabindex=0><code>Country_Region_Code eq &#39;ES&#39; or Country_Region_Code eq &#39;US&#39;
Country_Region_Code eq &#39;ES&#39; and Payment_Terms_Code eq &#39;14 DAYS&#39;
Entry_No ge 610
Entry_No lt 610
VAT_Bus_Posting_Group ne &#39;EXPORT&#39;
</code></pre><h4 id=odatag4>Odata.g4<a hidden class=anchor aria-hidden=true href=#odatag4>#</a></h4><pre tabindex=0><code>grammar OData;

/*
 * Parser Rules
 */

program: expression;

expression:
	LP expression RP # Parenthesis
	| K_STARTSWITH LP column=column_name &#39;,&#39; value=TEXT RP # StartsWith
	| K_ENDSWITH LP column=column_name &#39;,&#39; value=TEXT RP # EndsWith
	| K_CONTAINS LP column=column_name &#39;,&#39; value=TEXT RP # Contains
	| column=column_name K_IN LP value=decimal_array RP # InDecimal
	| column=column_name K_IN LP value=string_array RP # InText
	| column=column_name compare=(
		Equal
		| NotEqual
		| GreaterThan
		| GreaterThanOrEqual
		| LessThan
		| LessThanOrEqual) value=decimal # CompareDecimal
	| column=column_name compare=(
		Equal
		| NotEqual
		| GreaterThan
		| GreaterThanOrEqual
		| LessThan
		| LessThanOrEqual) value=TEXT # CompareText
	| expression logic = (K_AND | K_OR) expression	# Logic
	;

column_name
   : COLUMN_NAME
   | &#39;[&#39; column_name &#39;]&#39;
   ;

string_array
	: TEXT (&#39;,&#39; TEXT)*
	;

decimal_array
	: NUMBER (&#39;,&#39; NUMBER)*
	;

text: TEXT;

decimal
	: NUMBER
	;

/*
 * Lexer Rules
 */

K_IN: I N;
K_AND: A N D;
K_OR: O R;
K_STARTSWITH: S T A R T S W I T H;
K_ENDSWITH: E N D S W I T H;
K_CONTAINS: C O N T A I N S;
LP : &#39;(&#39;;
RP : &#39;)&#39;;

Equal: E Q;
NotEqual: N E;
GreaterThan: G T;
GreaterThanOrEqual: G E;
LessThan: L T;
LessThanOrEqual: L E;

COLUMN_NAME
   : VALID_ID_START VALID_ID_CHAR*
   ;

TEXT
	:&#39;&#34;&#39; .*? &#39;&#34;&#39;
	|&#39;\&#39;&#39; .*? &#39;\&#39;&#39;
	;

NUMBER
   : (SIGN)? UNSIGNED_INTEGER+
   | (SIGN)? UNSIGNED_INTEGER+ (&#39;.&#39; UNSIGNED_INTEGER+)?
   ;

fragment UNSIGNED_INTEGER
   : (&#39;0&#39; .. &#39;9&#39;)
   ;

fragment SIGN
   : (&#39;+&#39; | &#39;-&#39;)
   ;

fragment VALID_ID_START
   : LOWERCASE | UPERCASE | &#39;_&#39;
   ;

fragment VALID_ID_CHAR
   : VALID_ID_START | (LOWERCASE | UPERCASE | DIGIT )
   ;

fragment LOWERCASE: [a-z];
fragment UPERCASE: [A-Z];

fragment DIGIT: [0-9];
fragment DIGITS: DIGIT+;
fragment A: [aA];
fragment B: [bB];
fragment C: [cC];
fragment D: [dD];
fragment E: [eE];
fragment F: [fF];
fragment G: [gG];
fragment H: [hH];
fragment I: [iI];
fragment J: [jJ];
fragment K: [kK];
fragment L: [lL];
fragment M: [mM];
fragment N: [nN];
fragment O: [oO];
fragment P: [pP];
fragment Q: [qQ];
fragment R: [rR];
fragment S: [sS];
fragment T: [tT];
fragment U: [uU];
fragment V: [vV];
fragment W: [wW];
fragment X: [xX];
fragment Y: [yY];
fragment Z: [zZ];

SPACES: [ \u000B\t\r\n] -&gt; channel(HIDDEN);
</code></pre><h4 id=前端>前端<a hidden class=anchor aria-hidden=true href=#前端>#</a></h4><h5 id=ui>UI<a hidden class=anchor aria-hidden=true href=#ui>#</a></h5><p><div class=post-img-view><a data-fancybox=gallery href=https://s2.loli.net/2023/02/04/yraYmPKxQGb1d7j.png><img src=https://s2.loli.net/2023/02/04/yraYmPKxQGb1d7j.png alt=WX20230204-203415@2x.png></a></div></p><h5 id=npm包>npm包<a hidden class=anchor aria-hidden=true href=#npm包>#</a></h5><p><code>npm i antlr4@4.11.0</code></p><h5 id=visitordsl-to-js>Visitor（DSL to js）<a hidden class=anchor aria-hidden=true href=#visitordsl-to-js>#</a></h5><pre tabindex=0><code>
// This class defines a complete generic visitor for a parse tree produced by ODataParser.

import ODataParser from &#34;@/project/antlr/ODataParser&#34;;
import ODataVisitor from &#34;@/project/antlr/ODataVisitor&#34;;

export default class ODataSqlVisitor extends ODataVisitor {

	filterPair={
		logic:&#39;AND&#39;,
		pairs:[]
	}

	getFilterPair(){
		return this.filterPair
	}
	// Visit a parse tree produced by ODataParser#CompareText.
	visitCompareText(ctx) {
		if (ctx.exception!=null) {
			throw  ctx.exception;
		}
		const column = this.visit(ctx.column);
		const decimal= ctx.value.text.replace(/^&#34;(.*)&#34;$/,&#34;$1&#34;)
		const operator = this.getSQLOperator(ctx.compare.type);
		const pair= {column ,value: decimal,operator};
		this.filterPair.pairs.push(pair)
		return pair;
	}



	// Visit a parse tree produced by ODataParser#CompareDecimal.
	visitCompareDecimal(ctx) {
		if (ctx.exception!=null) {
			throw  ctx.exception;
		}
		const column = this.visit(ctx.column);
		const decimal = this.visit(ctx.value);
		const operator = this.getSQLOperator(ctx.compare.type);
		// return column + &#34; &#34; + operator + &#34; &#34; + decimal;
		const pair= {column ,value: decimal,operator};
		this.filterPair.pairs.push(pair)
		return pair;
	}


	// Visit a parse tree produced by ODataParser#Logic.
	visitLogic(ctx){
		if(ctx.exception!=null) {
			throw  ctx.exception;
		}
		const left = this.visit(ctx.expression(0));
        const right = this.visit(ctx.expression(1));
		if (right == null){
			return null;
		}
		if (ctx.logic.type== ODataParser.K_AND) {
			this.filterPair.logic = &#34;AND&#34;;
			// return left + &#34; and &#34; + right;
			return null;
		}else {
			this.filterPair.logic = &#34;OR&#34;;
			// return left + &#34; or &#34; + right;
			return null;
		}
	}




	// Visit a parse tree produced by ODataParser#column_name.
	visitColumn_name(ctx) {
		return ctx.getText();
	}


	// Visit a parse tree produced by ODataParser#decimal.
	visitDecimal(ctx) {
		return ctx.getText();
	}

	// visitText(ctx) {
	// 	const aa= ctx.getText().replace(/^&#34;(.*)&#34;$/,&#34;$1&#34;)
	// 	console.log(aa,ctx.getText())
	// 	debugger
	// 	return aa
	// }

	getSQLOperator(compare) {
		let operator = null;
		switch (compare) {
			case ODataParser.Equal:
				operator = &#34;=&#34;;
				break;
			case ODataParser.NotEqual:
				operator = &#34;&lt;&gt;&#34;;
				break;
			case ODataParser.GreaterThan:
				operator = &#34;&gt;&#34;;
				break;
			case ODataParser.GreaterThanOrEqual:
				operator = &#34;&gt;=&#34;;
				break;
			case ODataParser.LessThan:
				operator = &#34;&lt;&#34;;
				break;
			case ODataParser.LessThanOrEqual:
				operator = &#34;&lt;=&#34;;
				break;
		}
		return operator;
   }

}
</code></pre><h4 id=后端>后端<a hidden class=anchor aria-hidden=true href=#后端>#</a></h4><h5 id=maven坐标>maven坐标<a hidden class=anchor aria-hidden=true href=#maven坐标>#</a></h5><pre tabindex=0><code>&lt;!-- https://mvnrepository.com/artifact/org.antlr/antlr4-runtime --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.antlr&lt;/groupId&gt;
    &lt;artifactId&gt;antlr4-runtime&lt;/artifactId&gt;
    &lt;version&gt;4.11.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h5 id=visitordsl-to-sql-和工具类>Visitor（DSL to sql） 和工具类<a hidden class=anchor aria-hidden=true href=#visitordsl-to-sql-和工具类>#</a></h5><pre tabindex=0><code>package com.sankyu.wms.antlr;


import com.google.common.base.CaseFormat;

public class ODataSqlVisitor extends ODataBaseVisitor {
  @Override
  public Object visitLogic(ODataParser.LogicContext ctx) {
    if (ctx.exception!=null) {
      throw  ctx.exception;
    }
    String left = (String) visit(ctx.expression(0));
    String right = (String) visit(ctx.expression(1));
    if (right == null){
      return null;
    }
    if (ctx.logic.getType()==ODataParser.K_AND) {
      return left + &#34; and &#34; + right;
    }else {
      return left + &#34; or &#34; + right;
    }
  }

  @Override
  public Object visitColumn_name(ODataParser.Column_nameContext ctx) {
    return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, ctx.getText());
  }

  @Override
  public Object visitDecimal(ODataParser.DecimalContext ctx) {
    return ctx.getText();
  }

//  @Override
//  public Object visitText(ODataParser.TextContext ctx) {
//    return ctx.getText();
//  }

  @Override
  public Object visitCompareDecimal(ODataParser.CompareDecimalContext ctx) {
    if (ctx.exception!=null) {
      throw  ctx.exception;
    }
    String column = (String)visit(ctx.column);
    String decimal = (String)visit(ctx.value);
    String operator = getSQLOperator(ctx.compare.getType());
    return column + &#34; &#34; + operator + &#34; &#34; + decimal;
  }


  @Override
  public Object visitCompareText(ODataParser.CompareTextContext ctx) {
    if (ctx.exception!=null) {
      throw  ctx.exception;
    }
    String column = (String)visit(ctx.column);
    String decimal = ctx.value.getText();
    String operator = getSQLOperator(ctx.compare.getType());
    return column + &#34; &#34; + operator + &#34; &#34; + decimal;
  }


  private String getSQLOperator(Integer compare) {
    String operator = null;
    switch (compare) {
      case ODataParser.Equal:
        operator = &#34;=&#34;;
        break;
      case ODataParser.NotEqual:
        operator = &#34;&lt;&gt;&#34;;
        break;
      case ODataParser.GreaterThan:
        operator = &#34;&gt;&#34;;
        break;
      case ODataParser.GreaterThanOrEqual:
        operator = &#34;&gt;=&#34;;
        break;
      case ODataParser.LessThan:
        operator = &#34;&lt;&#34;;
        break;
      case ODataParser.LessThanOrEqual:
        operator = &#34;&lt;=&#34;;
        break;
    }
    return operator;
  }
}
</code></pre><h4 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h4><ol><li><a href=https://olingo.apache.org/doc/odata2/tutorials/Olingo_Tutorial_AdvancedRead_FilterVisitor.html>https://olingo.apache.org/doc/odata2/tutorials/Olingo_Tutorial_AdvancedRead_FilterVisitor.html</a></li><li><a href=https://blog.51cto.com/u_15067225/2603738>https://blog.51cto.com/u_15067225/2603738</a></li><li><a href=https://learn.microsoft.com/en-us/dynamics-nav/using-filter-expressions-in-odata-uris>https://learn.microsoft.com/en-us/dynamics-nav/using-filter-expressions-in-odata-uris</a></li><li><a href=https://github.com/huazailmh/ODataFilterParser/blob/master/Parser/ODataFilterVisitor.cs>https://github.com/huazailmh/ODataFilterParser/blob/master/Parser/ODataFilterVisitor.cs</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://xiaoqiaotq.github.io/tags/antlr4/>Antlr4</a></li><li><a href=https://xiaoqiaotq.github.io/tags/java/>JAVA</a></li><li><a href=https://xiaoqiaotq.github.io/tags/dsl/>DSL</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://xiaoqiaotq.github.io>xiaoqiaotq</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script></body></html>